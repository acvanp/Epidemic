x[which(round(x) %in% 2:98)]
# define markov chain function
ntrials = 10000
x = runif(n = 0:100, min = 1, max = 100)
for( i in 1:(ntrials-1) ) {
upd = (0 < x) & (x < N - 1)
birth = 1 * (runif(n = 1:100, min = 0, max = 1) <= a * x)
death = 1 * (runif(n = 1:100, min = 0, max = 1) <= b * x)
x[upd] = x[upd] + birth[upd] - death[upd]
if( length( x[which(round(x) %in% 2:98)]) < 11 ){x = runif(n = 0:100, min = 1, max = 100)}
}
hist(x)
# define markov chain function
ntrials = 15000
x = runif(n = 0:100, min = 1, max = 100)
for( i in 1:(ntrials-1) ) {
upd = (0 < x) & (x < N - 1)
birth = 1 * (runif(n = 1:100, min = 0, max = 1) <= a * x)
death = 1 * (runif(n = 1:100, min = 0, max = 1) <= b * x)
x[upd] = x[upd] + birth[upd] - death[upd]
if( length( x[which(round(x) %in% 2:98)]) < 11 ){x = runif(n = 0:100, min = 1, max = 100)}
}
hist(x)
# define markov chain function
ntrials = 18000
x = runif(n = 0:100, min = 1, max = 100)
for( i in 1:(ntrials-1) ) {
upd = (0 < x) & (x < N - 1)
birth = 1 * (runif(n = 1:100, min = 0, max = 1) <= a * x)
death = 1 * (runif(n = 1:100, min = 0, max = 1) <= b * x)
x[upd] = x[upd] + birth[upd] - death[upd]
if( length( x[which(round(x) %in% 2:98)]) < 11 ){x = runif(n = 0:100, min = 1, max = 100)}
}
hist(x)
install.packages("caTools")
getOption("repos")
install.packages(c("digest", "caTools", "bitops"))
install.packages(c("digest", "caTools", "bitops"))
options(repos = c(CRAN="https://cloud.r-project.org"))
install.packages(c("digest", "caTools", "bitops"))
install.packages(c("ggspatial", "git2r", "gss", "modelr", "pillar", "pkgbuild", "ps", "RcppArmadillo", "rematch2", "rgeos", "rlang", "sf", "tidyr", "usethis", "xml2", "zoo"))
library(caTools)
install.packages("caTools")
install.packages("installr")
library(installr)
updateR()
# Alex Van plantinga virus model
# April 2020
# City coronavirus analysis.R
# 30 days 104942 people    153 confirmed      7 deaths
library(fGarch)
SIR.model = function(ntrials,
pop,
daysrun,
asympt.cont,
sick.cont,
encounter.asymptomatic.nosocdist,
encounter.asymptomatic.socdist,
encounter.sick.input,
death.chance,
recover.time,
rate.asymptomatic,
incub.pd,
take.action,
med.scarcity.factor,
hosp.beds,
virus.evolves.mildness,
relax.socdist.mean.sick ){
recovered.list = list()
deaths.list = list()
confirmed.list = list()
succeptible.list = list()
removed.list = list()
sick.hist = c()
deaths.hist = c() # array of deaths for each run of the model,
# to make a histogram for different settings of death rate under different parameters
inf.max = c()
sick.volume = list()
#ntrials = 100
for(p in 1:ntrials){
#pop = 100000 # fixed population value
# seed the model with 5 infected people
succeptible = c(pop-5) #starting pop
recover.chance = 1/recover.time
infected.asymptomatic = c(2) # start with one infected person who shows no symptons and does not die
infected.sick = c(3) # separate the count of infected sick who have a 1/10 chance of dying
# 50% of the infected will get sick
infected.new = c(5) # distribution channel for each model iteration, feeds into inf.asympt or inf.sick
confirmed = c(3) # recognized confirmed cases based on sick cases
deaths = c(0) # those who die from the disease and are removed from the population
recovered = c(0) # those who recover and are removed from the population of potential host/victims
removed = c(5) # deaths + recovered, cannot be infected, removed from population pool of vulnerable
# asymptomatic cases are roughly "half as contagious" as sick people
# https://www.discovermagazine.com/health/asymptomatic-carriers-are-fueling-the-covid-19-pandemic-heres-why-you-dont
# # https://www.worldometers.info/coronavirus/coronavirus-death-rate/
# recover.chance = 1/21
# the factor that influences recovery rate, depends on how many people were sick two weeks ago
rr = 0
#incub.pd = 3 # let there be a 1-4 day incubation period
for(i in 2:daysrun){
#------------------------------
# INFECTIONS
#--------------------------
infected.new[i] = 0
# make the number of encounters random,
# but adjust the encounter rate depending on the volume of sick people
if(infected.sick[i-1] < take.action ){ # take.action is for the first implimentation of social distancing in the city
encounter.asymptomatic = encounter.asymptomatic.nosocdist
if(encounter.sick.input < encounter.asymptomatic){
encounter.sick = (encounter.asymptomatic.nosocdist - encounter.sick.input) / 5
}else(  encounter.sick = encounter.sick.input )
}else({
encounter.asymptomatic = encounter.asymptomatic.socdist
encounter.sick = encounter.sick.input
})
# Relax social distancing for asymptomatic people after two weeks
# User inputs the percent increase in sick threshold
if(i>14){
if(
#(1-rate.asymptomatic) * mean(infected.new[(i-8) : (i-1)]) > relax.socdist.mean.sick ){
mean(confirmed[(i-7) : (i-1)] - confirmed[(i-8) : (i-2)]) > relax.socdist.mean.sick ){
encounter.asymptomatic = encounter.asymptomatic.socdist
encounter.sick = encounter.sick.input
}else(
{
encounter.asymptomatic = encounter.asymptomatic.nosocdist
if(encounter.sick.input < encounter.asymptomatic){
encounter.sick = (encounter.asymptomatic.nosocdist - encounter.sick.input) / 5
}else(  encounter.sick = encounter.sick.input )
}
)
}
# Incubation inbub.pd determines what timeslice of infected people are spreading the disease
if(i > incub.pd){
# calculate the randum number of encounters
# the mean number will be encounter.sick by generating over the range 2*encounter.sick
# the infected who spread the disease where those infected as of 3days ago (inbub.pd)
# subtract the ones recovered in that elapsed time from
if(
round((infected.sick[i-incub.pd] - (recovered[i-1] - recovered[i-incub.pd]) * (1-rate.asymptomatic))) <= 0
|
round((infected.asymptomatic[i-incub.pd] - (recovered[i-1] - recovered[i-incub.pd]) * (rate.asymptomatic))) <= 0
){
rand.sick.encounters = 0
rand.asympt.encounters = 0
}else({
rand.sick.encounters = round(
sum(
abs(rsnorm( # calculate sick encounters using fGarch::rsnorm
round(
infected.sick[i-incub.pd] - (recovered[i-1] - recovered[i-incub.pd]) * (1-rate.asymptomatic)
)
# subtract the since-recovered people
, mean = encounter.sick, sd = 0.75*encounter.sick, xi = 10))
) #* (succeptible[i-1]/pop) # encounters multiplied by the availability of succiptible people
)
rand.asympt.encounters = round(
sum(
abs(rsnorm( # calculate again for asymptomatic people using fGarch::rsnorm
round(
infected.asymptomatic[i-incub.pd] - (recovered[i-1] - recovered[i-incub.pd]) * (rate.asymptomatic)
) # subtract the since-recovered people
, mean = encounter.asymptomatic, sd = 0.75 * encounter.asymptomatic, xi = 10))
) #* (succeptible[i-1]/pop) # encounters multiplied by the availability of succiptible people
)
# with the rand.sick.encounters and rand.asympt encounters in hand,
# make a vector of 1's and 0's representing the total number of succeptible (1's) and removed (0's), excluding the number of dead who do not interact in the future
shuffled.succeptible = c((1:succeptible[i-1])/(1:succeptible[i-1]), 0*(1: (removed[i-1] - deaths[i-1] ) ) )[sample(1:(pop - deaths[i-1] ), (pop - deaths[i-1] ), replace = FALSE)]
rand.sick.encounters = sum(shuffled.succeptible[1:rand.sick.encounters]) # sum the 1's and 0's from the random interactions
shuffled.succeptible = c((1:succeptible[i-1])/(1:succeptible[i-1]), 0*(1: ( removed[i-1] - deaths[i-1] ) ) )[sample(1: (pop - deaths[i-1] ), (pop - deaths[i-1] ), replace = FALSE)]
rand.asympt.encounters = sum(shuffled.succeptible[1:rand.asympt.encounters]) # sum the 1's and 0's from the random interactions
})
if(succeptible[i-1] > 0 && !is.na(rand.sick.encounters)){
# infections caused by encounters with sick people
x = runif(rand.sick.encounters, 0, 1)
# random interactions within the sick.contagiousness cutoff is a transmission to infected.new
infected.new[i] = infected.new[i] + length(x[which(x < sick.cont)])
}
# assume asymptomatic people have the chance to infect more people than sick people
if(succeptible[i-1] > 0 && !is.na(rand.sick.encounters)){
x = runif(rand.asympt.encounters, 0, 1)
infected.new[i] = infected.new[i] + length(x[which(x < asympt.cont)])
}else(infected.new[i] = 0)
}else(infected.new[i] =   round( # in the first three days of the model during the incubation period
sum(
runif(
removed[i-1], 0, 2 * encounter.asymptomatic * asympt.cont)
)
)
)
# if we run out of uninfected people in a trial, then infect all succeptibleing people
if(infected.new[i] > succeptible[i-1]){infected.new[i] = succeptible[i-1]; succeptible[i] = 0} # zero people succeptible
# randomly decide who of the new infections are sick and asymptomatic
asympt.new = 0 # counter variable
sick.new = 0 # counter variable
if(infected.new[i] > 0 ){
for(k in 1:infected.new[i]){
# 20% chance of being asymptomatic or being sick
if(rate.asymptomatic > runif(n = 1, min = 1e-12, max = 1)){
asympt.new = asympt.new + 1}else(sick.new = sick.new + 1)
}
}
# now we have have a count of new cases of sick and asymptomatic individuals for this iteration (day)
#-----------------------
# REMOVALS - outcomes of the previous day's sick and asymptomatic pools of people
#-------------------------
recovered.new.sick = 0 # those of the sick that recover
deaths.new = 0 # new deaths that come out of the pre-existing sick pool
if(infected.sick[i-1] > 0){
for(k in 1: ceiling( infected.sick[i-1] / recover.time) ) { # divide the daily outcomes by the recovery time
# if they die, count the death tally
# adjust chance of death while sick
# include a factor that increases the chance of death in proportion to the number of infections
# this can simulate the effect of the relative scarcity of medical resources
if(i > recover.time){
rr = (infected.asymptomatic[i-recover.time] + infected.sick[i-recover.time]) / pop # rr boosts the probability of recovery based on how many sick people 14 days ago
}else(rr = 0) # rr is the factor that increases recovery rate. It kicks in when i > 15. Start healing people after 15 days
# scarcity of hospital beds chances the death chance
if(infected.sick[i-1] < hosp.beds){
death.chance.mod = death.chance
}else(death.chance.mod = (death.chance + med.scarcity.factor*abs(infected.sick[i-1]/pop)) )
# if the user chooses "yes" to model a simple time-dependent evolution of a less deadly strain
# let it become half as virulent every 6 months
if(virus.evolves.mildness ==  "yes"){
if(infected.sick[i-1] > hosp.beds){death.chance.mod = # "decreasing deadliness" is same as death.chance.mod except that it decreases with the removal
(death.chance + med.scarcity.factor*abs(infected.sick[i-1]/pop)) * (1-removed[i-1]/pop)}else(
death.chance.mod = death.chance  * (1-removed[i-1]/pop)
)}
if( death.chance.mod  > runif(n = 1, min = 1e-12, max = 1)){
deaths.new = deaths.new + 1}else( # if they do not die, then give them a chance to recover
recovered.new.sick = recovered.new.sick + 1
#  1*((recover.chance + rr) > runif(n = 1, min = 1e-12, max = 1))
# multiply recover.chance by i, because chance of recovery increases with time
)
}
}
recovered.new.asympt = 0
# based on prev iteration count of inf.asympt people, how many recovered?
#if(i > 15){rr = 10}else(rr = 1) #already written above, but note this variable
if(infected.asymptomatic[i-1] > 0){
for(k in 1:infected.asymptomatic[i-1]){
recovered.new.asympt = recovered.new.asympt +
1*((recover.chance + rr) > runif(n = 1, min = 1e-12, max = 1))
# multiply recover.chance by i, because chance of recovery increases with time
}
}
############
# Update the chains
confirmed[i] = confirmed[i-1] + sick.new
# update for any deaths or recoveries and new cases
infected.sick[i] = infected.sick[i-1] + sick.new - deaths.new - recovered.new.sick
# update for recoveries and new cases
infected.asymptomatic[i] = infected.asymptomatic[i-1] + asympt.new - recovered.new.asympt
#if(infected.asymptomatic[i] < 0){infected.asymptomatic[i] = 0}
deaths[i] = deaths.new + deaths[i-1]
recovered[i] = recovered[i-1] + recovered.new.asympt + recovered.new.sick
# assign a value to the removed category
#if(infected.new[i] == succeptible[i-1] | removed[i-1] == pop){
#  removed[i] = pop}else(
removed[i] =   removed[i-1] + sick.new + asympt.new #+ removed[i-1] + infected.new[i])
# assign a value to the succeptibleing population
#if(!is.na(succeptible[i]) | succeptible[i-1] == 0){succeptible[i] = 0}else(succeptible[i] = pop - removed[i])
succeptible[i] = succeptible[i-1] - infected.new[i]
}
# timeseries builder section
deaths.hist = append(deaths.hist, deaths[length(deaths)])
inf.max = append(inf.max, max(infected.asymptomatic + infected.sick))
sick.hist = append(sick.hist, confirmed[length(confirmed)])
# lists
sick.volume[[p]] = infected.sick
recovered.list[[p]] = recovered
deaths.list[[p]] = deaths
confirmed.list[[p]] = confirmed
succeptible.list[[p]] =  succeptible
removed.list[[p]] = removed
# added a message to tell the user how many trials have run
if(p != ntrials){ message(paste("Running... Number of trials run:", p, "...")) }else(
message(paste(p, "trials complete!"))
)
}
# return from model multiple objects must be returned in a list
x = list(# inputs, conditions of the model
ntrials,
pop,
daysrun,
asympt.cont,
sick.cont,
encounter.asymptomatic.nosocdist,
encounter.asymptomatic.socdist,
encounter.sick,
death.chance,
recover.time,
rate.asymptomatic,
incub.pd,
take.action,
med.scarcity.factor,
hosp.beds,
relax.socdist.mean.sick,
#time series from the last iteration of the model
infected.asymptomatic,
infected.sick,
infected.new,
recovered,
deaths,
removed,
succeptible,
confirmed,
# return time series from trials
deaths.hist,
sick.volume,
inf.max,
sick.hist,
recovered.list,
deaths.list,
confirmed.list,
succeptible.list,
removed.list)
# give the items in the list names
names(x) = c(
# input names
"ntrials",
"pop",
"daysrun",
"asympt.cont",
"sick.cont",
"encounter.asymptomatic.nosocdist",
"encounter.asymptomatic.socdist",
"encounter.sick",
"death.chance",
"recover.time",
"rate.asymptomatic",
"incub.pd",
"take.action",
"med.scarcity.factor",
"hosp.beds",
"relax.socdist.mean.sick",
# time series from the last iteration of the model
"infected.asymptomatic",
"infected.sick",
"infected.new",
"recovered",
"deaths",
"removed",
"succeptible",
"confirmed",
# return time series from trials
"deaths.hist",
"sick.volume",
"inf.max",
"sick.hist",
"recovered.list",
"deaths.list",
"confirmed.list",
"succeptible.list",
"removed.list")
return(x)
}
# Alex Van Plantinga
# Apr and May 2020
# Plotter functions for the epidemiological model
# SIR.hist makes a histogram of models A and B
# SIR.plotter makes time series of the model results
#-------------------------
#### GGPLOT version of SIR.hist
SIR.hist = function(x, y){
# Deaths histogram
library(ggplot2)
df = data.frame(100 * x$deaths.hist / x$pop,
100 * y$deaths.hist / y$pop)
colnames(df) = c("Model_A", "Model_B")
df = melt(df)
d.hist = ggplot( df, aes(x = value, color = variable) ) +
geom_histogram( fill = "white", position = "dodge") +
geom_vline(xintercept = mean(100 * x$deaths.hist / x$pop),
col = "magenta", lty = 2, lwd = 1.1) +
geom_vline(xintercept = mean(100 * y$deaths.hist / y$pop),
col = "red", lty = 2, lwd = 1.1) +
scale_color_manual(values=c("magenta", "red")) +
scale_fill_manual(values=c("magenta", "red")) +
theme( legend.position = "top") +
labs(title = "Histogram: Mortality Rate Comparison\n(dashes = model average)",
x = "Death Rate (% of population)",
y = "Frequency (model trials)")
d.hist
#-------------------------
# Max infections, hosp beds histogram
df = data.frame(x$inf.max,
y$inf.max)
colnames(df) = c("Model_A", "Model_B")
df = melt(df)
max.inf.hist = ggplot( df, aes(x = value, color = variable) ) +
geom_histogram( fill = "white", position = "dodge") +
geom_vline(xintercept = mean(x$inf.max),
col = "magenta", lty = 2, lwd = 1.1) +
geom_vline(xintercept = mean(y$inf.max),
col = "red", lty = 2, lwd = 1.1) +
scale_color_manual(values=c("magenta", "red")) +
scale_fill_manual(values=c("magenta", "red")) +
theme( legend.position = "top") +
labs(title = "Histogram: Peak Infection Volume\n (hospital bed demand, dashes = model average)",
x = "Peak Infection Volume (indivuals)",
y = "Frequency (model trials)")
max.inf.hist
library("gridExtra")
grid.arrange(d.hist, max.inf.hist, nrow = 2)
}
SIR.plotter = function(x){
# average time series for ntrials
library(ggplot2)
library(reshape2)
daysrun = x$daysrun
if(daysrun == 1){
succeptible = x$succeptible
pop = x$pop
removed = x$removed
recovered = x$recovered
confirmed = x$confirmed
daysrun  = x$daysrun
deaths = x$deaths
sickvolume = x$infected.sick
}else({
deaths = round(rowMeans(simplify2array( x$deaths.list )))
succeptible = round(rowMeans(simplify2array( x$succeptible.list )))
removed = round(rowMeans(simplify2array( x$removed.list )))
recovered = round(rowMeans(simplify2array( x$recovered.list )))
confirmed = round(rowMeans(simplify2array( x$confirmed.list )))
daysrun = x$daysrun
pop = x$pop
sickvolume = round(rowMeans((simplify2array((x$sick.volume)))))
})
df = cbind(c(1:daysrun), succeptible, removed, recovered, confirmed, deaths, sickvolume)
colnames(df)[1] = "days"
df = melt(df, id = "days")
df = df[ (daysrun + 1 ) : nrow(df) , ]
colnames(df)[which(colnames(df) == "Var2")] = "Category"
p =
ggplot(df, aes(x = Var1, y = value)) +
geom_area(aes(color = Category, fill = Category),
alpha = 0.02,
position = position_dodge(0.8)
)  + geom_point(aes(color = Category, fill = Category)
)  +  scale_color_manual(
values = c("blue", "black", "green", "gold",   "darkred", "magenta")) +
scale_fill_manual(
values = c("blue", "black", "green", "gold",   "darkred", "magenta")
) + labs(x = "Days",
y = "Cases",
title = paste(pop, "population,", daysrun, "days,\n",
deaths[daysrun], "deaths,",
removed[daysrun], "true removal,",
confirmed[daysrun], " recorded", sep = " ")) +
scale_y_log10() + theme_minimal()
return(p)
}
#SIR.model()
x = SIR.model(ntrials = 1,
pop = 100000,
daysrun = 100,
asympt.cont = 0.15,
sick.cont = 0.45,
encounter.asymptomatic.nosocdist = 8,
encounter.asymptomatic.socdist = 0.7,
encounter.sick.input = 0.15,
death.chance = 0.02,
recover.time = 16,
rate.asymptomatic = 0.2,
incub.pd = 3,
take.action = 1000,
med.scarcity.factor = 0.9,
hosp.beds = 1500,
virus.evolves.mildness = "no",
relax.socdist.mean.sick = 2)
SIR.plotter(x)
#SIR.model()
x = SIR.model(ntrials = 1,
pop = 100000,
daysrun = 100,
asympt.cont = 0.15,
sick.cont = 0.45,
encounter.asymptomatic.nosocdist = 8,
encounter.asymptomatic.socdist = 0.7,
encounter.sick.input = 0.15,
death.chance = 0.02,
recover.time = 16,
rate.asymptomatic = 0.2,
incub.pd = 3,
take.action = 1000,
med.scarcity.factor = 0.9,
hosp.beds = 1500,
virus.evolves.mildness = "no",
relax.socdist.mean.sick = 30)
SIR.plotter(x)
#SIR.model()
x = SIR.model(ntrials = 1,
pop = 100000,
daysrun = 100,
asympt.cont = 0.15,
sick.cont = 0.45,
encounter.asymptomatic.nosocdist = 8,
encounter.asymptomatic.socdist = 0.7,
encounter.sick.input = 0.15,
death.chance = 0.02,
recover.time = 16,
rate.asymptomatic = 0.2,
incub.pd = 3,
take.action = 1000,
med.scarcity.factor = 0.9,
hosp.beds = 1500,
virus.evolves.mildness = "no",
relax.socdist.mean.sick = 10)
SIR.plotter(x)
shiny::runApp('C:/Users/Lenovo/Epidemic/RShiny SIR toy A-B-epi-model')
